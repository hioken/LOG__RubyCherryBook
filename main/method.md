## 説明
- 対象にhashが含まれているものは、構造体にも仕様できる

## 取得系
- `class`レシーバーのクラスを調べる
  - レシーバー.class
- `methods` 対象のクラスが持つメソッドを調べる

## 真偽系
- `nil?`
- `odd?`
- `include?()` 引数が含まれているか
- `has_key?`, `key?`, `include?`, `member` 引数のキーがhashに含まれているかどうか

## 計算系
- `round()` 引数の桁になるように四捨五入する
  - 正の数が小数点第何位か、負の数-1, -2, -3が1, 10, 100に対応している
- `divmod()` 商と余りを配列で返す
  - 割られる数.divmod(割る数) => [商, 余り]

## 文字列系
- `rjust` 桁を揃える
  - 対象.rjust(桁数, 埋める文字)
  - '3'.rjust(3, '0') => "003"

- `chars` 文字列を1文字ずつ分割して配列にする

- `split()` 文字列を引数の文字を区切りとして区切って、配列にする
  - "apple,orange,berry".split(',') => ["apple", "orange", "berry"]

- `scan()` 文字列を分割して配列を返す
  - 対象.scan(正規表現、または部分文字列)
  - '12ab34'.scan(/../) => ["12", "ab", "34"]
  - 引数の書きかた色々あるので、要リサーチ

- `gsub` 対象の文字列を、第一引数を第二引数にreplaceした文字列を返す

- `sprintf(, )` 指定したフォーマットの文字列生成
  - sprintf('フォーマット指定子', 対象) => フォーマットに沿った対象の文字列

## 処理系
- `times{}` レシーバーの数だけループ処理をする
  - ブロック引数を渡すと、それが0からスタートする
- `upto(), downto(), step()` レシーバーの数から引数の数まで処理をループされる
  - ブロック引数はindex番号で、初期値はレシーバー
  - stepは、第二引数で、加減値を設定出来る
  - サンプル
```
  a = []; 2.upto(4){ |n| a << n } => a == [2, 3, 4]
```
## 配列/hash系
### 非ループ 操作
- `delete()` 対象から特定の値/keyを全て削除して整列する
  - 破壊
  - 対象.delete(値/key)
  - ブロックを渡すと、見つからなかった時の戻り値を設定できる
    - 対象.delete(値/key) { |値/key| "#{値/key}は見つかりませんでした" }

### 非ループ 配列のみ
- `join()` 配列を連結させた文字列の生成
  - 配列.join('区切り文字')

- `grep()` 配列の中から引数を含んだ物を返す

- `values_at()` 引数の添え字部分だけを配列として作成
  - 配列のみ対象
  - 配列.values_at(添え字, 添え字...)

- `delete_at()` 配列の特定の箇所を削除して整列する
  - 破壊
  - 配列のみ対象
  - 配列.delete_at(添え字)
  - 戻り値は削除した値

### 非ループ hashのみ
- `keys`, `values` key/valueをそれぞれ配列に入れて返す
- `merge()` レシーバーの中に引数のhashを混ぜる

### ループ 再編
- `delete_if{}` 配列を順番に参照して、処理の最終的な真偽が真なら削除、最後に整列
  - 配列のみ対象
  - 破壊
  - 配列.delete_if do |ブロック|; 処理; end

- `select{}` 戻り値がtrueになる要素を集め(falseになる要素を削除)、最終的に残った物を戻り値として返す
  - !で破壊
  - 配列.select do |ブロック|; 処理; end
  - falseバージョンにrejectがある

- `map{}` 戻り値を順に新しい配列に格納していき、最終的に生成された配列を返す
  - !で破壊
  - 配列.map do |ブロック|; 処理; end
  - hashに対して使っても、戻り値は配列

### ループ 取得
- `find{}` 最初に戻り値が真になった要素を戻り値として返す
  - ブロック
  - 配列.find { |block| 処理 }

### ループ 処理
- `each{}` いつもの

- `inject(){}` たたみ込み算をする
  - 引数が初期値、第一ブロックが足されていく数、第二ブロックがそのループの対象データ
  - 対象: 配列, hash
  - 引数, ブロック*2
  - 対象.inject(引数) { |block1, block2| block1に対する計算処理 } => ブロック1の最終的な値
  - 記述しなくても、処理に対して自動的に block1 = が追加されて、block1 = 処理 として計算される
  - 文字列にも使用可能

- `with_index(){}` indexを追加
  - ループ処理メソッドをレシーバーとすることで、その処理に、index番号を表す第二ブロック引数を追加、引数はindexの初期値
  - 対象: 配列, hash
  - 引数, ブロック
  - 対象.each等.with_index(indexの初期値) do |eachのブロック, index番号|; indexは1ループごとに+=1される; end
  - 元のメソッドのブロック引数が複数ある場合、そのブロック引数を()でくくる必要がある
